[{"id":"d11324b19b05ce1c671aea0ac57ea0cf","title":"搜索与图论模板","content":"本篇文章旨在介绍搜索与图论模板。\n在算法竞赛中，普通的指针建图方式过于慢了，所以采用数组的存储方式，最短路算法以及最小生成树算法很重要，spfa算法一般不用，因为spfa容易被卡，dijkstra算法用的比较多\n包括：树与图的存储，拓扑排序，朴素dijkstra，堆优化版dijkstra，Bellman-Ford算法，spfa 算法（队列优化的Bellman-Ford算法），spfa判断图中是否存在负环，floyd算法，朴素版prim算法，Kruskal算法，染色法判别二分图，匈牙利算法\n整理自acwing\n树与图的存储&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n&#x2F;&#x2F; 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 初始化\nidx &#x3D; 0;\nmemset(h, -1, sizeof h);\n\n\n树与图的遍历深度优先搜索(dfs)int dfs(int u)\n&#123;\n    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过\n\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;\n846. 树的重心\n\n广度优先搜索(bfs)queue&lt;int&gt; q;\nst[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n&#123;\n    int t &#x3D; q.front();\n    q.pop();\n\n    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过\n            q.push(j);\n        &#125;\n    &#125;\n&#125;\n847. 图中点的层次 \n\n拓扑排序bool topsort()\n&#123;\n    int hh &#x3D; 0, tt &#x3D; -1;\n\n    &#x2F;&#x2F; d[i] 存储点i的入度\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (!d[i])\n            q[ ++ tt] &#x3D; i;\n\n    while (hh &lt;&#x3D; tt)\n    &#123;\n        int t &#x3D; q[hh ++ ];\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (-- d[j] &#x3D;&#x3D; 0)\n                q[ ++ tt] &#x3D; j;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt &#x3D;&#x3D; n - 1;\n&#125;\n848. 有向图的拓扑序列 \n\n最短路算法朴素dijkstraint g[N][N];  &#x2F;&#x2F; 存储每条边\nint dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离\nbool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; n - 1; i ++ )\n    &#123;\n        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        &#x2F;&#x2F; 用t更新其他点的距离\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);\n\n        st[t] &#x3D; true;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n849. Dijkstra求最短路 I \n\n堆优化版dijkstratypedef pair&lt;int, int&gt; PII;\n\nint n;      &#x2F;&#x2F; 点的数量\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号\n\n    while (heap.size())\n    &#123;\n        auto t &#x3D; heap.top();\n        heap.pop();\n\n        int ver &#x3D; t.second, distance &#x3D; t.first;\n\n        if (st[ver]) continue;\n        st[ver] &#x3D; true;\n\n        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] &#x3D; distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n850. Dijkstra求最短路 II \n\nBellman-Ford算法注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\n\nint n, m;       &#x2F;&#x2F; n表示点数，m表示边数\nint dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离\n\nstruct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        for (int j &#x3D; 0; j &lt; m; j ++ )\n        &#123;\n            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] &#x3D; dist[a] + w;\n        &#125;\n    &#125;\n\n    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;\n    return dist[n];\n&#125;\n853. 有边数限制的最短路 \n\nspfa 算法（队列优化的Bellman-Ford算法）int n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] &#x3D; true;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n851. spfa求最短路 \n\nspfa判断图中是否存在负环int n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    &#x2F;&#x2F; 不需要初始化dist数组\n    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int&gt; q;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        q.push(i);\n        st[i] &#x3D; true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                cnt[j] &#x3D; cnt[t] + 1;\n                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n852. spfa判断负环\n\nfloyd算法(多源最短路)初始化：\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;\n            else d[i][j] &#x3D; INF;\n\n&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n854. Floyd求最短路 \n\n最小生成树算法朴素版prim算法int n;      &#x2F;&#x2F; n表示点数\nint g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边\nint dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中\n\n\n&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    int res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        int t &#x3D; -1;\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;\n\n        if (i) res +&#x3D; dist[t];\n        st[t] &#x3D; true;\n\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);\n    &#125;\n\n    return res;\n&#125;\n858. Prim算法求最小生成树 \n\nKruskal算法int n, m;       &#x2F;&#x2F; n是点数，m是边数\nint p[N];       &#x2F;&#x2F; 并查集的父节点数组\n\nstruct Edge     &#x2F;&#x2F; 存储边\n&#123;\n    int a, b, w;\n\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\n\nint find(int x)     &#x2F;&#x2F; 并查集核心操作\n&#123;\n    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集\n\n    int res &#x3D; 0, cnt &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; m; i ++ )\n    &#123;\n        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;\n\n        a &#x3D; find(a), b &#x3D; find(b);\n        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并\n        &#123;\n            p[a] &#x3D; b;\n            res +&#x3D; w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n859. Kruskal算法求最小生成树\n\n染色法判别二分图int n;      &#x2F;&#x2F; n表示点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图\nint color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] &#x3D; c;\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (color[j] &#x3D;&#x3D; -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] &#x3D;&#x3D; c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag &#x3D; true;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (color[i] &#x3D;&#x3D; -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag &#x3D; false;\n                break;\n            &#125;\n    return flag;\n&#125;\n861. 二分图的最大匹配 \n\n匈牙利算法int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n&#123;\n    for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true;\n            if (match[j] &#x3D;&#x3D; 0 || find(match[j]))\n            &#123;\n                match[j] &#x3D; x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n&#125;\n860. 染色法判定二分图 \n","slug":"搜索与图论模板","date":"2022-04-10T12:18:56.000Z","categories_index":"","tags_index":"模板,算法,搜索,图论,dfs,bfs","author_index":"Soul_15a"},{"id":"80578d34de98ea10cb7435fc76a1d430","title":"常用STL容器","content":"本篇文章旨在介绍常用STL容器。\n整理自acwing\n………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….\nvector, 变长数组，倍增的思想size()  返回元素个数\nempty()  返回是否为空\nclear()  清空\nfront()&#x2F;back()\npush_back()&#x2F;pop_back()\nbegin()&#x2F;end()\n[]\n支持比较运算，按字典序\n\n\npair&lt;int, int&gt;first, 第一个元素\nsecond, 第二个元素\n支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\n\nstring，字符串size()&#x2F;length()  返回字符串长度\nempty()\nclear()\nsubstr(起始下标，(子串长度))  返回子串\nc_str()  返回字符串所在字符数组的起始地址\n\n\nqueue, 队列size()\nempty()\npush()  向队尾插入一个元素\nfront()  返回队头元素\nback()  返回队尾元素\npop()  弹出队头元素\n\n\npriority_queue, 优先队列，默认是大根堆size()\nempty()\npush()  插入一个元素\ntop()  返回堆顶元素\npop()  弹出堆顶元素\n定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\n\nstack, 栈size()\nempty()\npush()  向栈顶插入一个元素\ntop()  返回栈顶元素\npop()  弹出栈顶元素\n\n\ndeque, 双端队列size()\nempty()\nclear()\nfront()&#x2F;back()\npush_back()&#x2F;pop_back()\npush_front()&#x2F;pop_front()\nbegin()&#x2F;end()\n[]\n\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列size()\nempty()\nclear()\nbegin()&#x2F;end()\n++, -- 返回前驱和后继，时间复杂度 O(logn)\n\nset&#x2F;multiset\n    insert()  插入一个数\n    find()  查找一个数\n    count()  返回某一个数的个数\n    erase()\n        (1) 输入是一个数x，删除所有x   O(k + logn)\n        (2) 输入一个迭代器，删除这个迭代器\n    lower_bound()&#x2F;upper_bound()\n        lower_bound(x)  返回大于等于x的最小的数的迭代器\n        upper_bound(x)  返回大于x的最小的数的迭代器\nmap&#x2F;multimap\n    insert()  插入的数是一个pair\n    erase()  输入的参数是pair或者迭代器\n    find()\n    []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n    lower_bound()&#x2F;upper_bound()\n\n\nunordered_set, unordered_map, unordered_multiset,unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--\n\n\nbitset, 圧位bitset&lt;10000&gt; s;\n~, &amp;, |, ^\n&gt;&gt;, &lt;&lt;\n&#x3D;&#x3D;, !&#x3D;\n[]\n\ncount()  返回有多少个1\n\nany()  判断是否至少有一个1\nnone()  判断是否全为0\n\nset()  把所有位置成1\nset(k, v)  将第k位变成v\nreset()  把所有位变成0\nflip()  等价于~\nflip(k) 把第k位取反","slug":"常用STL容器","date":"2022-04-10T12:09:45.000Z","categories_index":"","tags_index":"模板,算法,STL","author_index":"Soul_15a"},{"id":"1df484034a65ae4d42f3134f61bf20af","title":"数据结构模板","content":"本篇文章旨在介绍基础数据结构模板。\n算法竞赛中，利用指针的数据结构跑的太慢，故使用数组来表示的数据结构\n包括：单链表 双链表 栈 队列 单调栈 单调队列 KMP Trie树 并查集 堆 一般哈希 字符串哈希\n整理自acwing………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….\n单链表&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    head &#x3D; -1;\n    idx &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head &#x3D; ne[head];\n&#125;\n826. 单链表 \n双链表&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    &#x2F;&#x2F;0是左端点，1是右端点\n    r[0] &#x3D; 1, l[1] &#x3D; 0;\n    idx &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] &#x3D; x;\n    l[idx] &#x3D; a, r[idx] &#x3D; r[a];\n    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] &#x3D; l[a];\n    r[l[a]] &#x3D; r[a];\n&#125;\n827. 双链表 \n栈&#x2F;&#x2F; tt表示栈顶\nint stk[N], tt &#x3D; 0;\n\n&#x2F;&#x2F; 向栈顶插入一个数\nstk[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从栈顶弹出一个数\ntt -- ;\n\n&#x2F;&#x2F; 栈顶的值\nstk[tt];\n\n&#x2F;&#x2F; 判断栈是否为空\nif (tt &gt; 0)\n&#123;\n\n&#125;\n828. 模拟栈 \n队列\n\n\n\n\n\n\n\n\n普通队列\n循环队列\n普通队列&#x2F;&#x2F; hh 表示队头，tt表示队尾\nint q[N], hh &#x3D; 0, tt &#x3D; -1;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh &lt;&#x3D; tt)\n&#123;\n&#125;\n\n循环队列&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh &#x3D; 0, tt &#x3D; 0;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[tt ++ ] &#x3D; x;\nif (tt &#x3D;&#x3D; N) tt &#x3D; 0;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\nif (hh &#x3D;&#x3D; N) hh &#x3D; 0;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh !&#x3D; tt)\n&#123;\n\n&#125;\n829. 模拟队列 \n单调栈常见模型：找出每个数左边离它最近的比它大&#x2F;小的数\nint tt &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] &#x3D; i;\n&#125;\n830. 单调栈 \n单调队列常见模型：找出滑动窗口中的最大值&#x2F;最小值\nint hh &#x3D; 0, tt &#x3D; -1;\nfor (int i &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (hh &lt;&#x3D; tt &amp;&amp; check_out(q[hh])) hh ++ ;  &#x2F;&#x2F; 判断队头是否滑出窗口\n    while (hh &lt;&#x3D; tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] &#x3D; i;\n&#125;\n154. 滑动窗口 \nKMP&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度\n求模式串的Next数组：\nfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )\n&#123;\n    while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    ne[i] &#x3D; j;\n&#125;\n\n&#x2F;&#x2F; 匹配\nfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    if (j &#x3D;&#x3D; m)\n    &#123;\n        j &#x3D; ne[j];\n        &#x2F;&#x2F; 匹配成功后的逻辑\n    &#125;\n&#125;\n831. KMP字符串 \nTrie树int son[N][26], cnt[N], idx;\n&#x2F;&#x2F; 0号点既是根节点，又是空节点\n&#x2F;&#x2F; son[][]存储树中每个节点的子节点\n&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量\n\n&#x2F;&#x2F; 插入一个字符串\nvoid insert(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) son[p][u] &#x3D; ++ idx;\n        p &#x3D; son[p][u];\n    &#125;\n    cnt[p] ++ ;\n&#125;\n\n&#x2F;&#x2F; 查询字符串出现的次数\nint query(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) return 0;\n        p &#x3D; son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n835. Trie字符串统计 \n并查集(1)朴素并查集：\n\n    int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点\n\n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n\n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;\n\n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n\n\n(2)维护size的并查集：\n\n    int p[N], size[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n\n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n\n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        size[i] &#x3D; 1;\n    &#125;\n\n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    size[find(b)] +&#x3D; size[find(a)];\n    p[find(a)] &#x3D; find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\n    int p[N], d[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n\n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x)\n        &#123;\n            int u &#x3D; find(p[x]);\n            d[x] +&#x3D; d[p[x]];\n            p[x] &#x3D; u;\n        &#125;\n        return p[x];\n    &#125;\n\n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        d[i] &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n    d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量\n836. 合并集合 \n837. 连通块中点的数量 \n堆&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置\n&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n&#x2F;&#x2F; 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\n\nvoid down(int u)\n&#123;\n    int t &#x3D; u;\n    if (u * 2 &lt;&#x3D; size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;\n    if (u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;\n    if (u !&#x3D; t)\n    &#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int u)\n&#123;\n    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])\n    &#123;\n        heap_swap(u, u &#x2F; 2);\n        u &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; O(n)建堆\nfor (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);\n838. 堆排序\n839. 模拟堆 \n一般哈希(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n\n    &#x2F;&#x2F; 向哈希表中插入一个数\n    void insert(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        e[idx] &#x3D; x;\n        ne[idx] &#x3D; h[k];\n        h[k] &#x3D; idx ++ ;\n    &#125;\n\n    &#x2F;&#x2F; 在哈希表中查询某个数是否存在\n    bool find(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])\n            if (e[i] &#x3D;&#x3D; x)\n                return true;\n\n        return false;\n    &#125;\n\n(2) 开放寻址法\n    int h[N];\n\n    &#x2F;&#x2F; 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    &#123;\n        int t &#x3D; (x % N + N) % N;\n        while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x)\n        &#123;\n            t ++ ;\n            if (t &#x3D;&#x3D; N) t &#x3D; 0;\n        &#125;\n        return t;\n    &#125;\n840. 模拟散列表 \n字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n&#x2F;&#x2F; 初始化\np[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    h[i] &#x3D; h[i - 1] * P + str[i];\n    p[i] &#x3D; p[i - 1] * P;\n&#125;\n\n&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n841. 字符串哈希 \n","slug":"数据结构模板","date":"2022-04-10T11:55:19.000Z","categories_index":"","tags_index":"模板,算法,数据结构","author_index":"Soul_15a"},{"id":"cad29d88a5e84162d8735ff1cbc7e6a8","title":"基础算法模板","content":"本篇文章旨在介绍基础算法模板。\n二分，前缀和，差分，双指针较重要，望重点掌握\n包括：快速排序，归并排序，离散化，前缀和，差分，双指针，区间合并，高精度，位运算\n整理自acwing………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….\n快速排序模板void quick_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;\n\n学思想\nalgorithm库中有一个sort函数相当于快排，不用手写\n785. 快速排序\n\n归并排序模板void merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int mid &#x3D; l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];\n        else tmp[k ++ ] &#x3D; q[j ++ ];\n\n    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];\n    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];\n\n    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];\n&#125;\n\n787.归并排序\n利用归并排序的思想可以解决逆序对的问题\n788. 逆序对的数量\n\n二分\n\n\n\n\n\n\n\n\n整数二分\n浮点数二分\n整数二分模板bool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质\n        else l &#x3D; mid + 1;\n    &#125;\n    return l;\n&#125;\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l &#x3D; mid;\n        else r &#x3D; mid - 1;\n    &#125;\n    return l;\n&#125;\n\n789. 数的范围\n浮点数二分bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid &#x3D; (l + r) &#x2F; 2;\n        if (check(mid)) r &#x3D; mid;\n        else l &#x3D; mid;\n    &#125;\n    return l;\n&#125;\n\n790. 数的三次方根\n\n高精度缺少高精度乘高精度\n\n\n\n\n\n\n\n\n\n高精度加法\n高精度减法\n高精度乘以高精度\n高精度除以高精度\n高精度加法&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t +&#x3D; A[i];\n        if (i &lt; B.size()) t +&#x3D; B[i];\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;\n\n791. 高精度加法\n高精度减法&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t &#x3D; A[i] - t;\n        if (i &lt; B.size()) t -&#x3D; B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t &#x3D; 1;\n        else t &#x3D; 0;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n\n792. 高精度减法\n高精度乘以低精度&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t +&#x3D; A[i] * b;\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n    return C;\n&#125;\n\n793. 高精度乘法\n高精度除以低精度&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r &#x3D; 0;\n    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )\n    &#123;\n        r &#x3D; r * 10 + A[i];\n        C.push_back(r &#x2F; b);\n        r %&#x3D; b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n\n794. 高精度除法\n\n前缀和\n\n\n\n\n\n\n\n\n一维前缀和\n二维前缀和\n一维前缀和S[i] &#x3D; a[1] + a[2] + ... a[i]\na[l] + ... + a[r] &#x3D; S[r] - S[l - 1]\n\n795. 前缀和\n二维前缀和S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n\n796. 子矩阵的和\n\n差分\n\n\n\n\n\n\n\n\n一维差分\n二维差分\n一维差分给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c\n\n797. 差分\n二维差分给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c\n\n798. 差分矩阵\n\n位运算求n的第k位数字: n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n\n\n801. 二进制中1的个数\n\n双指针算法for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n\n    &#x2F;&#x2F; 具体问题的逻辑\n&#125;\n常见问题分类：\n    (1) 对于一个序列，用两个指针维护一段区间\n    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n\n799. 最长连续不重复子序列\n800. 数组元素的目标和\n\n离散化vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;\n\n802. 区间和\n\n区间合并&#x2F;&#x2F; 将所有存在交集的区间合并\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st &#x3D; -2e9, ed &#x3D; -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n            st &#x3D; seg.first, ed &#x3D; seg.second;\n        &#125;\n        else ed &#x3D; max(ed, seg.second);\n\n    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs &#x3D; res;\n&#125;\n\n803.区间合并\n\n","slug":"基础算法模板","date":"2022-04-10T09:57:57.000Z","categories_index":"","tags_index":"模板,算法,基础算法","author_index":"Soul_15a"}]