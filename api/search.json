[{"id":"a00b2defe973fe8d6ab3038de496d7b1","title":"JDBC","content":"概念JDBC概述\n\n\n\n\n\n\n\n\nJDBC 是使用Java语言操作关系型数据库的一套API\nJava DataBase Connectivity\nJDBC本质\n官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口\n各个数据库厂商去实现这套接口，提供数据库驱动jar包\n我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类\n\nJDBC好处\n各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发\n可随时替换底层数据库，访问数据库的Java代码基本不变\n\n以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。\nJDBC在java中的操作步骤第一步：编写Java代码\n第二步：Java代码将SQL发送到MySQL服务端\n第三步：MySQL服务端接收到SQL语句并执行该SQL语句\n第四步：将SQL语句执行的结果返回给Java代码\nJDBC操作1.导入jar包下载地址\n2.注册驱动(高版本的jar包已经不需要这一步操作)Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n3.获取连接Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n\n4.定义sql语句String sql &#x3D; &quot;&quot;;\n\n5.获取SQL对象Statement stmt &#x3D; conn.createStatement();\n\n6.执行SQLstmt.executeUpdate(sql);\n\nConnectionConnection（数据库连接对象）作用：\n\n获取执行 SQL 的对象\n管理事务\n\nconnection管理事务下面代码的false代表不自动提交，即开启事务\ntry &#123;\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开启事务&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        conn.setAutoCommit(false);\n        &#x2F;&#x2F;5. 执行sql\n        int count1 &#x3D; stmt.executeUpdate(sql1);&#x2F;&#x2F;受影响的行数\n        &#x2F;&#x2F;6. 处理结果\n        System.out.println(count1);\n        int i &#x3D; 3&#x2F;0;\n        &#x2F;&#x2F;5. 执行sql\n        int count2 &#x3D; stmt.executeUpdate(sql2);&#x2F;&#x2F;受影响的行数\n        &#x2F;&#x2F;6. 处理结果\n        System.out.println(count2);\n\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;提交事务&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        &#x2F;&#x2F;程序运行到此处，说明没有出现任何问题，则需求提交事务\n        conn.commit();\n    &#125; catch (Exception e) &#123;\n        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;回滚事务&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n        &#x2F;&#x2F;程序在出现异常时会执行到这个地方，此时就需要回滚事务\n        conn.rollback();\n        e.printStackTrace();\n    &#125;\n\nStatement处理sql语句的查询以外的操作\nResultSetResultSet（结果集对象）作用：\n\n&#x3D;&#x3D;封装了SQL查询语句的结果。&#x3D;&#x3D;\n\n而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下：\nResultSet  executeQuery(sql)：执行DQL 语句，返回 ResultSet 对象\n\n那么我们就需要从 ResultSet 对象中获取我们想要的数据。ResultSet 对象提供了操作查询结果数据的方法，如下：\n\n\n\n\n\n\n\n\n\nboolean  next()\n\n将光标从当前位置向前移动一行 \n判断当前行是否为有效行\n\n方法返回值说明：\n\ntrue  ： 有效航，当前行有数据\nfalse ： 无效行，当前行没有数据\n\n\n\n\n\n\n\n\n\n\nxxx  getXxx(参数)：获取数据\n\nxxx : 数据类型；如： int getInt(参数) ；String getString(参数)\n参数\nint类型的参数：列的编号，从1开始\nString类型的参数： 列的名称\n\n\n\n一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 next() 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 getInt(&quot;id&quot;) 获取当前行id字段的值，也可以通过 getString(&quot;name&quot;) 获取当前行name字段的值。如果想获取下一行的数据，继续调用 next()  方法，以此类推。\nPreparedStatement\n\n\n\n\n\n\n\n\nPreparedStatement作用：\n\n预编译SQL语句并执行：预防SQL注入问题\n\n\n获取 PreparedStatement 对象\n&#x2F;&#x2F; SQL语句中的参数值，使用？占位符替代\nString sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ?&quot;;\n&#x2F;&#x2F; 通过Connection对象获取，并传入对应的sql语句\nPreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n设置参数值\n上面的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ?  的值。\n\n\n\n\n\n\n\n\n\nPreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值\n\nXxx：数据类型 ； 如 setInt (参数1，参数2)\n\n参数：\n\n参数1： ？的位置编号，从1 开始\n\n参数2： ？的值\n\n\n\n\n\n执行SQL语句\n\n\n\n\n\n\n\n\n\nexecuteUpdate();  执行DDL语句和DML语句\nexecuteQuery();  执行DQL语句\n&#x3D;&#x3D;注意：&#x3D;&#x3D;\n\n调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。\n\n原理: 对预编译的一些字符进行转义处理\n\n\n数据库连接池简介\n\n\n\n\n\n\n\n\n\n数据库连接池是个容器，负责分配、管理数据库连接(Connection)\n\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；\n\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n\n好处\n\n资源重用\n提升系统响应速度\n避免数据库连接遗漏\n\n\n\n之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。\n而数据库使用了数据库连接池后，就能达到Connection对象的复用,连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。\n数据库连接池实现\n标准接口：&#x3D;&#x3D;DataSource&#x3D;&#x3D;\n官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：\nConnection getConnection()\n\n那么以后就不需要通过 DriverManager 对象获取 Connection 对象，而是通过连接池（DataSource）获取 Connection 对象。\n\n常见的数据库连接池\n\nDBCP\nC3P0\nDruid\n\n我们现在使用更多的是Druid，它的性能比其他两个会好一些。\n\nDruid（德鲁伊）\n\nDruid连接池是阿里巴巴开源的数据库连接池项目 \n\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n\n\n\n4.3  Driud使用下载地址\n\n\n\n\n\n\n\n\n\n\n导入jar包 druid-1.1.12.jar\n定义配置文件\n加载配置文件\n获取数据库连接池对象\n获取连接\n\n现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件\n编写配置文件如下：\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&amp;useServerPrepStmts&#x3D;true\nusername&#x3D;root\npassword&#x3D;1234\n# 初始化连接数量\ninitialSize&#x3D;5\n# 最大连接数\nmaxActive&#x3D;10\n# 最大等待时间\nmaxWait&#x3D;3000\n\n使用druid的代码如下：\n&#x2F;**\n * Druid数据库连接池演示\n *&#x2F;\npublic class DruidDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;1.导入jar包\n        &#x2F;&#x2F;2.定义配置文件\n        &#x2F;&#x2F;3. 加载配置文件\n        Properties prop &#x3D; new Properties();\n        prop.load(new FileInputStream(&quot;jdbc-demo&#x2F;src&#x2F;druid.properties&quot;));\n        &#x2F;&#x2F;4. 获取连接池对象\n        DataSource dataSource &#x3D; DruidDataSourceFactory.createDataSource(prop);\n\n        &#x2F;&#x2F;5. 获取数据库连接 Connection\n        Connection connection &#x3D; dataSource.getConnection();\n        System.out.println(connection); &#x2F;&#x2F;获取到了连接后就可以继续做其他操作了\n\n        &#x2F;&#x2F;System.out.println(System.getProperty(&quot;user.dir&quot;));\n    &#125;\n&#125;\n\n","slug":"JDBC","date":"2022-04-18T07:09:34.000Z","categories_index":"","tags_index":"java,sql,jdbc","author_index":"Soul_15a"},{"id":"ff3dfd0caecb8a3b5b7353d12c1be784","title":"mysql基础","content":"引用—-黑马程序员javawebMySQL基础SQL\n英文：Structured Query Language，简称 SQL，结构化查询语言\n操作关系型数据库的编程语言\n定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用SQL来操作。\n\n通用语句\nSQL 语句可以单行或多行书写，以分号结尾。\n\nMySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n\n注释\n\n单行注释: – 注释内容 或 #注释内容(MySQL 特有) \n\n\n\n\n\n\n\n\n\n注意：使用– 添加单行注释时，–后面一定要加空格，而#没有要求。\n\n多行注释: &#x2F;* 注释 *&#x2F;\n\n\n\n\nSQL分类\nDDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等\nDDL简单理解就是用来操作数据库，表等\n\nDML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改\nDML简单理解就对表中数据进行增删改\n\nDQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据)\nDQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。\n\nDCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户\nDML简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。\n\n\n\n\n\n\n\n\n\n\n\n注意： 以后我们最常操作的是 DML 和 DQL  ，因为我们开发中最常操作的就是数据。\nDDL:操作数据库我们先来学习DDL来操作数据库。而操作数据库主要就是对数据库的增删查操作。\n查询查询所有的数据库\nSHOW DATABASES;\n\n上述查询到的是的这些数据库是mysql安装好自带的数据库，我们以后不要操作这些数据库。\n创建数据库\n创建数据库：\n\nCREATE DATABASE 数据库名称;\n\n\n而在创建数据库的时候，我并不知道db1数据库有没有创建，直接再次创建名为db1的数据库就会出现错误。\n为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。\n\n创建数据库(判断，如果不存在则创建)\n\nCREATE DATABASE IF NOT EXISTS 数据库名称;\n\n\n\n删除数据库\n删除数据库\n\nDROP DATABASE 数据库名称;\n\n\n删除数据库(判断，如果存在则删除)\n\nDROP DATABASE IF EXISTS 数据库名称;\n\n使用数据库数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。\n\n使用数据库\n\nUSE 数据库名称;\n\n\n查看当前使用的数据库\n\nSELECT DATABASE();\n\n\n\nDDL:操作表操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。\n查询表\n查询当前数据库下所有表名称\n\nSHOW TABLES;\n\n我们创建的数据库中没有任何表，因此我们进入mysql自带的mysql数据库，执行上述语句查看\n\n查询表结构\n\nDESC 表名称;\n\n查看mysql数据库中func表的结构\n创建表\n创建表\n\nCREATE TABLE 表名 (\n\t字段名1  数据类型1,\n\t字段名2  数据类型2,\n\t…\n\t字段名n  数据类型n\n);\n\n\n\n\n\n\n\n\n\n\n\n注意：最后一行末尾，不能加逗号\n知道了创建表的语句，那么我们创建创建如下结构的表\ncreate table tb_user (\n\tid int,\n    username varchar(20),\n    password varchar(32)\n);\n\n\n数据类型MySQL 支持多种类型，可以分为三类：\n\n数值\ntinyint : 小整数型，占一个字节\nint\t： 大整数类型，占四个字节\n\teg ： age int\ndouble ： 浮点类型\n\t使用格式： 字段名 double(总长度,小数点后保留的位数)\n\teg ： score double(5,2)   \n\n日期\ndate ： 日期值。只包含年月日\n\teg ：birthday date ： \ndatetime ： 混合日期和时间值。包含年月日时分秒\n\n字符串\nchar ： 定长字符串。\n\t优点：存储性能高\n\t缺点：浪费空间\n\teg ： name char(10)  如果存储的数据字符个数不足10个，也会占10个的空间\nvarchar ： 变长字符串。\n\t优点：节约空间\n\t缺点：存储性能底\n\teg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间\t\n\n删除表\n删除表\n\nDROP TABLE 表名;\n\n\n删除表时判断表是否存在\n\nDROP TABLE IF EXISTS 表名;\n\n\n修改表\n修改表名\n\nALTER TABLE 表名 RENAME TO 新的表名;\n\n-- 将表名student修改为stu\nalter table student rename to stu;\n\n\n添加一列\n\nALTER TABLE 表名 ADD 列名 数据类型;\n\n-- 给stu表添加一列address，该字段类型是varchar(50)\nalter table stu add address varchar(50);\n\n\n修改数据类型\n\nALTER TABLE 表名 MODIFY 列名 新数据类型;\n\n-- 将stu表中的address字段的类型改为 char(50)\nalter table stu modify address char(50);\n\n\n修改列名和数据类型\n\nALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;\n\n-- 将stu表中的address字段名改为 addr，类型改为varchar(50)\nalter table stu change address addr varchar(50);\n\n\n删除列\n\nALTER TABLE 表名 DROP 列名;\n\n-- 将stu表中的addr字段 删除\nalter table stu drop addr;\n\n\n\n6，navicat使用通过上面的学习，我们发现在命令行中写sql语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。\nnavicat概述\nNavicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。\n这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。\n官网： http://www.navicat.com.cn\n\nnavicat使用建立和mysql服务的连接第一步： 点击连接，选择MySQL\n第二步：填写连接数据库必要的信息\n\n\n\n\n\n\n\n\n\n\n操作连接成功后就能看到如下图界面：\n\n修改表结构\n\n点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息：\n\n编写SQL语句并执行\n\nDMLDML主要是对数据进行增（insert）删（delete）改（update）操作。\n添加数据\n给指定列添加数据\n\nINSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);\n\n\n给全部列添加数据\n\nINSERT INTO 表名 VALUES(值1,值2,…);\n\n\n批量添加数据\n\nINSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\nINSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\n\nselect * from stu;\n\n\n\n-- 给指定列添加数据\nINSERT INTO stu (id, NAME) VALUES (1, &#39;张三&#39;);\n-- 给所有列添加数据，列名的列表可以省略的\nINSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1);\n\nINSERT INTO stu VALUES (2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1);\n\n-- 批量添加数据\nINSERT INTO stu VALUES \n\t(2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1),\n\t(2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1),\n\t(2,&#39;李四&#39;,&#39;男&#39;,&#39;1999-11-11&#39;,88.88,&#39;lisi@itcast.cn&#39;,&#39;13888888888&#39;,1);\n\n\n\n修改数据\n修改表数据\n\nUPDATE 表名 SET 列名1&#x3D;值1,列名2&#x3D;值2,… [WHERE 条件] ;\n\n\n注意：\n\n修改语句中如果不加条件，则将所有数据都修改！\n像上面的语句中的中括号，表示在写sql语句中可以省略这部分\n\n\n练习\n\n将张三的性别改为女\n\n  update stu set sex &#x3D; &#39;女&#39; where name &#x3D; &#39;张三&#39;;\n\n\n将张三的生日改为 1999-12-12 分数改为99.99\nupdate stu set birthday &#x3D; &#39;1999-12-12&#39;, score &#x3D; 99.99 where name &#x3D; &#39;张三&#39;;\n\n注意：如果update语句没有加where条件，则会将表中所有数据全部修改！\nupdate stu set sex &#x3D; &#39;女&#39;;\n\n上面语句的执行完后查询到的结果是：\n\n\n\n\n\n删除数据\n删除数据\n\nDELETE FROM 表名 [WHERE 条件] ;\n\n\n练习\n\n-- 删除张三记录\ndelete from stu where name &#x3D; &#39;张三&#39;;\n\n-- 删除stu表中所有的数据\ndelete from stu;\n\n\n\nDQL接下来我们先介绍查询的完整语法：\nSELECT \n    字段列表\nFROM \n    表名列表 \nWHERE \n    条件列表\nGROUP BY\n    分组字段\nHAVING\n    分组后条件\nORDER BY\n    排序字段\nLIMIT\n    分页限定\n\n为了给大家演示查询的语句，我们需要先准备表及一些数据：\n-- 删除stu表\ndrop table if exists stu;\n\n\n-- 创建stu表\nCREATE TABLE stu (\n id int, -- 编号\n name varchar(20), -- 姓名\n age int, -- 年龄\n sex varchar(5), -- 性别\n address varchar(100), -- 地址\n math double(5,2), -- 数学成绩\n english double(5,2), -- 英语成绩\n hire_date date -- 入学时间\n);\n\n-- 添加数据\nINSERT INTO stu(id,NAME,age,sex,address,math,english,hire_date) \nVALUES \n(1,&#39;马运&#39;,55,&#39;男&#39;,&#39;杭州&#39;,66,78,&#39;1995-09-01&#39;),\n(2,&#39;马花疼&#39;,45,&#39;女&#39;,&#39;深圳&#39;,98,87,&#39;1998-09-01&#39;),\n(3,&#39;马斯克&#39;,55,&#39;男&#39;,&#39;香港&#39;,56,77,&#39;1999-09-02&#39;),\n(4,&#39;柳白&#39;,20,&#39;女&#39;,&#39;湖南&#39;,76,65,&#39;1997-09-05&#39;),\n(5,&#39;柳青&#39;,20,&#39;男&#39;,&#39;湖南&#39;,86,NULL,&#39;1998-09-01&#39;),\n(6,&#39;刘德花&#39;,57,&#39;男&#39;,&#39;香港&#39;,99,99,&#39;1998-09-01&#39;),\n(7,&#39;张学右&#39;,22,&#39;女&#39;,&#39;香港&#39;,99,99,&#39;1998-09-01&#39;),\n(8,&#39;德玛西亚&#39;,18,&#39;男&#39;,&#39;南京&#39;,56,65,&#39;1994-09-02&#39;);\n\n接下来咱们从最基本的查询语句开始学起。\n基础查询语法\n查询多个字段\n\nSELECT 字段列表 FROM 表名;\nSELECT * FROM 表名; -- 查询所有数据\n\n\n去除重复记录\n\nSELECT DISTINCT 字段列表 FROM 表名;\n\n\n起别名\n\nAS: AS 也可以省略\n\n\n\n练习\n查询name、age两列\nselect name,age from stu;\n\n查询所有列的数据，列名的列表可以使用*替代\nselect * from stu;\n\n上面语句中的*不建议大家使用，因为在这写*不方便我们阅读sql语句。我们写字段列表的话，可以添加注释对每一个字段进行说明\n而在上课期间为了简约课程的时间，老师很多地方都会写*。\n\n查询地址信息\nselect address from stu;\n\n执行上面语句结果如下：\n\n从上面的结果我们可以看到有重复的数据，我们也可以使用 distinct 关键字去重重复数据。\n\n去除重复记录\nselect distinct address from stu;\n\n查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略）\nselect name,math as 数学成绩,english as 英文成绩 from stu;\nselect name,math 数学成绩,english 英文成绩 from stu;\n\n条件查询语法SELECT 字段列表 FROM 表名 WHERE 条件列表;\n\n\n条件\n\n条件列表可以使用以下运算符\n条件查询练习\n查询年龄大于20岁的学员信息\nselect * from stu where age &gt; 20;\n\n查询年龄大于等于20岁的学员信息\nselect * from stu where age &gt;&#x3D; 20;\n\n查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息\nselect * from stu where age &gt;&#x3D; 20 &amp;&amp;  age &lt;&#x3D; 30;\nselect * from stu where age &gt;&#x3D; 20 and  age &lt;&#x3D; 30;\n\n\n\n\n\n\n\n\n\n\n上面语句中 &amp;&amp;  和  and  都表示并且的意思。建议使用 and 。\n也可以使用  between … and 来实现上面需求\nselect * from stu where age BETWEEN 20 and 30;\n\n查询入学日期在’1998-09-01’ 到 ‘1999-09-01’  之间的学员信息\nselect * from stu where hire_date BETWEEN &#39;1998-09-01&#39; and &#39;1999-09-01&#39;;\n\n查询年龄等于18岁的学员信息\nselect * from stu where age &#x3D; 18;\n\n查询年龄不等于18岁的学员信息\nselect * from stu where age !&#x3D; 18;\nselect * from stu where age &lt;&gt; 18;\n\n查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息\nselect * from stu where age &#x3D; 18 or age &#x3D; 20 or age &#x3D; 22;\nselect * from stu where age in (18,20 ,22);\n\n查询英语成绩为 null的学员信息\nnull值的比较不能使用 &#x3D;  或者 !&#x3D; 。需要使用 is  或者 is not\nselect * from stu where english &#x3D; null; -- 这个语句是不行的\nselect * from stu where english is null;\nselect * from stu where english is not null;\n\n模糊查询练习\n\n\n\n\n\n\n\n\n模糊查询使用like关键字，可以使用通配符进行占位:\n（1）_ : 代表单个任意字符\n（2）% : 代表任意个数字符\n\n查询姓’马’的学员信息\nselect * from stu where name like &#39;马%&#39;;\n\n查询第二个字是’花’的学员信息  \nselect * from stu where name like &#39;_花%&#39;;\n\n查询名字中包含 ‘德’ 的学员信息\nselect * from stu where name like &#39;%德%&#39;;\n\n排序查询语法SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;\n\n上述语句中的排序方式有两种，分别是：\n\nASC ： 升序排列 （默认值）\nDESC ： 降序排列\n\n\n\n\n\n\n\n\n\n\n注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序\n练习\n查询学生信息，按照年龄升序排列 \nselect * from stu order by age ;\n\n查询学生信息，按照数学成绩降序排列\nselect * from stu order by math desc ;\n\n查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列\nselect * from stu order by math desc , english asc ;\n\n聚合函数概念 &#x3D;&#x3D;将一列数据作为一个整体，进行纵向计算。&#x3D;&#x3D;\n现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。\n聚合函数分类\n\n\n函数名\n功能\n\n\n\ncount(列名)\n统计数量（一般选用不为null的列）\n\n\nmax(列名)\n最大值\n\n\nmin(列名)\n最小值\n\n\nsum(列名)\n求和\n\n\navg(列名)\n平均值\n\n\n聚合函数语法SELECT 聚合函数名(列名) FROM 表;\n\n\n\n\n\n\n\n\n\n\n注意：null 值不参与所有聚合函数运算\n练习\n统计班级一共有多少个学生\nselect count(id) from stu;\nselect count(english) from stu;\n\n上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*)\nselect count(*) from stu;\n\n查询数学成绩的最高分\nselect max(math) from stu;\n\n查询数学成绩的最低分\nselect min(math) from stu;\n\n查询数学成绩的总分\nselect sum(math) from stu;\n\n查询数学成绩的平均分\nselect avg(math) from stu;\n\n查询英语成绩的最低分\nselect min(english) from stu;\n\n分组查询语法SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];\n\n\n\n\n\n\n\n\n\n\n注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义\n练习\n查询男同学和女同学各自的数学平均分\nselect sex, avg(math) from stu group by sex;\n\n\n\n\n\n\n\n\n\n\n注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义\nselect name, sex, avg(math) from stu group by sex;  -- 这里查询name字段就没有任何意义\n\n查询男同学和女同学各自的数学平均分，以及各自人数\nselect sex, avg(math),count(*) from stu group by sex;\n\n查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组\nselect sex, avg(math),count(*) from stu where math &gt; 70 group by sex;\n\n查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的\nselect sex, avg(math),count(*) from stu where math &gt; 70 group by sex having count(*)  &gt; 2;\n\nwhere 和 having 区别：\n\n执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。\n\n可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。\n\n\n分页查询如下图所示，大家在很多网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。\n接下来我们先说分页查询的语法。\n语法SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;\n\n\n\n\n\n\n\n\n\n\n注意： 上述语句中的起始索引是从0开始\n练习\n从0开始查询，查询3条数据\nselect * from stu limit 0 , 3;\n\n每页显示3条数据，查询第1页数据\nselect * from stu limit 0 , 3;\n\n每页显示3条数据，查询第2页数据\nselect * from stu limit 3 , 3;\n\n每页显示3条数据，查询第3页数据\nselect * from stu limit 6 , 3;\n\n从上面的练习推导出起始索引计算公式：\n起始索引 &#x3D; (当前页码 - 1) * 每页显示的条数\n\n","slug":"mysql基础","date":"2022-04-14T03:26:44.000Z","categories_index":"","tags_index":"-mysql","author_index":"Soul_15a"},{"id":"d11324b19b05ce1c671aea0ac57ea0cf","title":"搜索与图论模板","content":"本篇文章旨在介绍搜索与图论模板。\n在算法竞赛中，普通的指针建图方式过于慢了，所以采用数组的存储方式，最短路算法以及最小生成树算法很重要，spfa算法一般不用，因为spfa容易被卡，dijkstra算法用的比较多\n包括：树与图的存储，拓扑排序，朴素dijkstra，堆优化版dijkstra，Bellman-Ford算法，spfa 算法（队列优化的Bellman-Ford算法），spfa判断图中是否存在负环，floyd算法，朴素版prim算法，Kruskal算法，染色法判别二分图，匈牙利算法\n整理自acwing\n树与图的存储&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n&#x2F;&#x2F; 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 初始化\nidx &#x3D; 0;\nmemset(h, -1, sizeof h);\n\n\n树与图的遍历深度优先搜索(dfs)int dfs(int u)\n&#123;\n    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过\n\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;\n846. 树的重心\n\n广度优先搜索(bfs)queue&lt;int&gt; q;\nst[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n&#123;\n    int t &#x3D; q.front();\n    q.pop();\n\n    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过\n            q.push(j);\n        &#125;\n    &#125;\n&#125;\n847. 图中点的层次 \n\n拓扑排序bool topsort()\n&#123;\n    int hh &#x3D; 0, tt &#x3D; -1;\n\n    &#x2F;&#x2F; d[i] 存储点i的入度\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (!d[i])\n            q[ ++ tt] &#x3D; i;\n\n    while (hh &lt;&#x3D; tt)\n    &#123;\n        int t &#x3D; q[hh ++ ];\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (-- d[j] &#x3D;&#x3D; 0)\n                q[ ++ tt] &#x3D; j;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt &#x3D;&#x3D; n - 1;\n&#125;\n848. 有向图的拓扑序列 \n\n最短路算法朴素dijkstraint g[N][N];  &#x2F;&#x2F; 存储每条边\nint dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离\nbool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; n - 1; i ++ )\n    &#123;\n        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        &#x2F;&#x2F; 用t更新其他点的距离\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);\n\n        st[t] &#x3D; true;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n849. Dijkstra求最短路 I \n\n堆优化版dijkstratypedef pair&lt;int, int&gt; PII;\n\nint n;      &#x2F;&#x2F; 点的数量\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号\n\n    while (heap.size())\n    &#123;\n        auto t &#x3D; heap.top();\n        heap.pop();\n\n        int ver &#x3D; t.second, distance &#x3D; t.first;\n\n        if (st[ver]) continue;\n        st[ver] &#x3D; true;\n\n        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] &#x3D; distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n850. Dijkstra求最短路 II \n\nBellman-Ford算法注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\n\nint n, m;       &#x2F;&#x2F; n表示点数，m表示边数\nint dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离\n\nstruct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        for (int j &#x3D; 0; j &lt; m; j ++ )\n        &#123;\n            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] &#x3D; dist[a] + w;\n        &#125;\n    &#125;\n\n    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;\n    return dist[n];\n&#125;\n853. 有边数限制的最短路 \n\nspfa 算法（队列优化的Bellman-Ford算法）int n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] &#x3D; true;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n851. spfa求最短路 \n\nspfa判断图中是否存在负环int n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    &#x2F;&#x2F; 不需要初始化dist数组\n    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int&gt; q;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        q.push(i);\n        st[i] &#x3D; true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                cnt[j] &#x3D; cnt[t] + 1;\n                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n852. spfa判断负环\n\nfloyd算法(多源最短路)初始化：\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;\n            else d[i][j] &#x3D; INF;\n\n&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n854. Floyd求最短路 \n\n最小生成树算法朴素版prim算法int n;      &#x2F;&#x2F; n表示点数\nint g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边\nint dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中\n\n\n&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    int res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        int t &#x3D; -1;\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;\n\n        if (i) res +&#x3D; dist[t];\n        st[t] &#x3D; true;\n\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);\n    &#125;\n\n    return res;\n&#125;\n858. Prim算法求最小生成树 \n\nKruskal算法int n, m;       &#x2F;&#x2F; n是点数，m是边数\nint p[N];       &#x2F;&#x2F; 并查集的父节点数组\n\nstruct Edge     &#x2F;&#x2F; 存储边\n&#123;\n    int a, b, w;\n\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\n\nint find(int x)     &#x2F;&#x2F; 并查集核心操作\n&#123;\n    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集\n\n    int res &#x3D; 0, cnt &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; m; i ++ )\n    &#123;\n        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;\n\n        a &#x3D; find(a), b &#x3D; find(b);\n        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并\n        &#123;\n            p[a] &#x3D; b;\n            res +&#x3D; w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n859. Kruskal算法求最小生成树\n\n染色法判别二分图int n;      &#x2F;&#x2F; n表示点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图\nint color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] &#x3D; c;\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (color[j] &#x3D;&#x3D; -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] &#x3D;&#x3D; c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag &#x3D; true;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (color[i] &#x3D;&#x3D; -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag &#x3D; false;\n                break;\n            &#125;\n    return flag;\n&#125;\n861. 二分图的最大匹配 \n\n匈牙利算法int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n&#123;\n    for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true;\n            if (match[j] &#x3D;&#x3D; 0 || find(match[j]))\n            &#123;\n                match[j] &#x3D; x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n&#125;\n860. 染色法判定二分图 \n","slug":"搜索与图论模板","date":"2022-04-10T12:18:56.000Z","categories_index":"","tags_index":"模板,算法,搜索,图论,dfs,bfs","author_index":"Soul_15a"},{"id":"80578d34de98ea10cb7435fc76a1d430","title":"常用STL容器","content":"本篇文章旨在介绍常用STL容器。\n整理自acwing\n………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….\nvector, 变长数组，倍增的思想size()  返回元素个数\nempty()  返回是否为空\nclear()  清空\nfront()&#x2F;back()\npush_back()&#x2F;pop_back()\nbegin()&#x2F;end()\n[]\n支持比较运算，按字典序\n\n\npair&lt;int, int&gt;first, 第一个元素\nsecond, 第二个元素\n支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\n\nstring，字符串size()&#x2F;length()  返回字符串长度\nempty()\nclear()\nsubstr(起始下标，(子串长度))  返回子串\nc_str()  返回字符串所在字符数组的起始地址\n\n\nqueue, 队列size()\nempty()\npush()  向队尾插入一个元素\nfront()  返回队头元素\nback()  返回队尾元素\npop()  弹出队头元素\n\n\npriority_queue, 优先队列，默认是大根堆size()\nempty()\npush()  插入一个元素\ntop()  返回堆顶元素\npop()  弹出堆顶元素\n定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\n\nstack, 栈size()\nempty()\npush()  向栈顶插入一个元素\ntop()  返回栈顶元素\npop()  弹出栈顶元素\n\n\ndeque, 双端队列size()\nempty()\nclear()\nfront()&#x2F;back()\npush_back()&#x2F;pop_back()\npush_front()&#x2F;pop_front()\nbegin()&#x2F;end()\n[]\n\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列size()\nempty()\nclear()\nbegin()&#x2F;end()\n++, -- 返回前驱和后继，时间复杂度 O(logn)\n\nset&#x2F;multiset\n    insert()  插入一个数\n    find()  查找一个数\n    count()  返回某一个数的个数\n    erase()\n        (1) 输入是一个数x，删除所有x   O(k + logn)\n        (2) 输入一个迭代器，删除这个迭代器\n    lower_bound()&#x2F;upper_bound()\n        lower_bound(x)  返回大于等于x的最小的数的迭代器\n        upper_bound(x)  返回大于x的最小的数的迭代器\nmap&#x2F;multimap\n    insert()  插入的数是一个pair\n    erase()  输入的参数是pair或者迭代器\n    find()\n    []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n    lower_bound()&#x2F;upper_bound()\n\n\nunordered_set, unordered_map, unordered_multiset,unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--\n\n\nbitset, 圧位bitset&lt;10000&gt; s;\n~, &amp;, |, ^\n&gt;&gt;, &lt;&lt;\n&#x3D;&#x3D;, !&#x3D;\n[]\n\ncount()  返回有多少个1\n\nany()  判断是否至少有一个1\nnone()  判断是否全为0\n\nset()  把所有位置成1\nset(k, v)  将第k位变成v\nreset()  把所有位变成0\nflip()  等价于~\nflip(k) 把第k位取反","slug":"常用STL容器","date":"2022-04-10T12:09:45.000Z","categories_index":"","tags_index":"模板,算法,STL","author_index":"Soul_15a"},{"id":"1df484034a65ae4d42f3134f61bf20af","title":"数据结构模板","content":"本篇文章旨在介绍基础数据结构模板。\n算法竞赛中，利用指针的数据结构跑的太慢，故使用数组来表示的数据结构\n包括：单链表 双链表 栈 队列 单调栈 单调队列 KMP Trie树 并查集 堆 一般哈希 字符串哈希\n整理自acwing………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….\n单链表&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    head &#x3D; -1;\n    idx &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head &#x3D; ne[head];\n&#125;\n826. 单链表 \n双链表&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    &#x2F;&#x2F;0是左端点，1是右端点\n    r[0] &#x3D; 1, l[1] &#x3D; 0;\n    idx &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] &#x3D; x;\n    l[idx] &#x3D; a, r[idx] &#x3D; r[a];\n    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] &#x3D; l[a];\n    r[l[a]] &#x3D; r[a];\n&#125;\n827. 双链表 \n栈&#x2F;&#x2F; tt表示栈顶\nint stk[N], tt &#x3D; 0;\n\n&#x2F;&#x2F; 向栈顶插入一个数\nstk[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从栈顶弹出一个数\ntt -- ;\n\n&#x2F;&#x2F; 栈顶的值\nstk[tt];\n\n&#x2F;&#x2F; 判断栈是否为空\nif (tt &gt; 0)\n&#123;\n\n&#125;\n828. 模拟栈 \n队列\n\n\n\n\n\n\n\n\n普通队列\n循环队列\n普通队列&#x2F;&#x2F; hh 表示队头，tt表示队尾\nint q[N], hh &#x3D; 0, tt &#x3D; -1;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh &lt;&#x3D; tt)\n&#123;\n&#125;\n\n循环队列&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh &#x3D; 0, tt &#x3D; 0;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[tt ++ ] &#x3D; x;\nif (tt &#x3D;&#x3D; N) tt &#x3D; 0;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\nif (hh &#x3D;&#x3D; N) hh &#x3D; 0;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh !&#x3D; tt)\n&#123;\n\n&#125;\n829. 模拟队列 \n单调栈常见模型：找出每个数左边离它最近的比它大&#x2F;小的数\nint tt &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] &#x3D; i;\n&#125;\n830. 单调栈 \n单调队列常见模型：找出滑动窗口中的最大值&#x2F;最小值\nint hh &#x3D; 0, tt &#x3D; -1;\nfor (int i &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (hh &lt;&#x3D; tt &amp;&amp; check_out(q[hh])) hh ++ ;  &#x2F;&#x2F; 判断队头是否滑出窗口\n    while (hh &lt;&#x3D; tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] &#x3D; i;\n&#125;\n154. 滑动窗口 \nKMP&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度\n求模式串的Next数组：\nfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )\n&#123;\n    while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    ne[i] &#x3D; j;\n&#125;\n\n&#x2F;&#x2F; 匹配\nfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    if (j &#x3D;&#x3D; m)\n    &#123;\n        j &#x3D; ne[j];\n        &#x2F;&#x2F; 匹配成功后的逻辑\n    &#125;\n&#125;\n831. KMP字符串 \nTrie树int son[N][26], cnt[N], idx;\n&#x2F;&#x2F; 0号点既是根节点，又是空节点\n&#x2F;&#x2F; son[][]存储树中每个节点的子节点\n&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量\n\n&#x2F;&#x2F; 插入一个字符串\nvoid insert(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) son[p][u] &#x3D; ++ idx;\n        p &#x3D; son[p][u];\n    &#125;\n    cnt[p] ++ ;\n&#125;\n\n&#x2F;&#x2F; 查询字符串出现的次数\nint query(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) return 0;\n        p &#x3D; son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n835. Trie字符串统计 \n并查集(1)朴素并查集：\n\n    int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点\n\n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n\n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;\n\n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n\n\n(2)维护size的并查集：\n\n    int p[N], size[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n\n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n\n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        size[i] &#x3D; 1;\n    &#125;\n\n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    size[find(b)] +&#x3D; size[find(a)];\n    p[find(a)] &#x3D; find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\n    int p[N], d[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n\n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x)\n        &#123;\n            int u &#x3D; find(p[x]);\n            d[x] +&#x3D; d[p[x]];\n            p[x] &#x3D; u;\n        &#125;\n        return p[x];\n    &#125;\n\n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        d[i] &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n    d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量\n836. 合并集合 \n837. 连通块中点的数量 \n堆&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置\n&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n&#x2F;&#x2F; 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\n\nvoid down(int u)\n&#123;\n    int t &#x3D; u;\n    if (u * 2 &lt;&#x3D; size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;\n    if (u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;\n    if (u !&#x3D; t)\n    &#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int u)\n&#123;\n    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])\n    &#123;\n        heap_swap(u, u &#x2F; 2);\n        u &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; O(n)建堆\nfor (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);\n838. 堆排序\n839. 模拟堆 \n一般哈希(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n\n    &#x2F;&#x2F; 向哈希表中插入一个数\n    void insert(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        e[idx] &#x3D; x;\n        ne[idx] &#x3D; h[k];\n        h[k] &#x3D; idx ++ ;\n    &#125;\n\n    &#x2F;&#x2F; 在哈希表中查询某个数是否存在\n    bool find(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])\n            if (e[i] &#x3D;&#x3D; x)\n                return true;\n\n        return false;\n    &#125;\n\n(2) 开放寻址法\n    int h[N];\n\n    &#x2F;&#x2F; 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    &#123;\n        int t &#x3D; (x % N + N) % N;\n        while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x)\n        &#123;\n            t ++ ;\n            if (t &#x3D;&#x3D; N) t &#x3D; 0;\n        &#125;\n        return t;\n    &#125;\n840. 模拟散列表 \n字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n&#x2F;&#x2F; 初始化\np[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    h[i] &#x3D; h[i - 1] * P + str[i];\n    p[i] &#x3D; p[i - 1] * P;\n&#125;\n\n&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n841. 字符串哈希 \n","slug":"数据结构模板","date":"2022-04-10T11:55:19.000Z","categories_index":"","tags_index":"模板,算法,数据结构","author_index":"Soul_15a"},{"id":"cad29d88a5e84162d8735ff1cbc7e6a8","title":"基础算法模板","content":"本篇文章旨在介绍基础算法模板。\n二分，前缀和，差分，双指针较重要，望重点掌握\n包括：快速排序，归并排序，离散化，前缀和，差分，双指针，区间合并，高精度，位运算\n整理自acwing………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….\n快速排序模板void quick_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;\n\n学思想\nalgorithm库中有一个sort函数相当于快排，不用手写\n785. 快速排序\n\n归并排序模板void merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int mid &#x3D; l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];\n        else tmp[k ++ ] &#x3D; q[j ++ ];\n\n    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];\n    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];\n\n    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];\n&#125;\n\n787.归并排序\n利用归并排序的思想可以解决逆序对的问题\n788. 逆序对的数量\n\n二分\n\n\n\n\n\n\n\n\n整数二分\n浮点数二分\n整数二分模板bool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质\n        else l &#x3D; mid + 1;\n    &#125;\n    return l;\n&#125;\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l &#x3D; mid;\n        else r &#x3D; mid - 1;\n    &#125;\n    return l;\n&#125;\n\n789. 数的范围\n浮点数二分bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid &#x3D; (l + r) &#x2F; 2;\n        if (check(mid)) r &#x3D; mid;\n        else l &#x3D; mid;\n    &#125;\n    return l;\n&#125;\n\n790. 数的三次方根\n\n高精度缺少高精度乘高精度\n\n\n\n\n\n\n\n\n\n高精度加法\n高精度减法\n高精度乘以高精度\n高精度除以高精度\n高精度加法&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t +&#x3D; A[i];\n        if (i &lt; B.size()) t +&#x3D; B[i];\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;\n\n791. 高精度加法\n高精度减法&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t &#x3D; A[i] - t;\n        if (i &lt; B.size()) t -&#x3D; B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t &#x3D; 1;\n        else t &#x3D; 0;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n\n792. 高精度减法\n高精度乘以低精度&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t +&#x3D; A[i] * b;\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n    return C;\n&#125;\n\n793. 高精度乘法\n高精度除以低精度&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r &#x3D; 0;\n    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )\n    &#123;\n        r &#x3D; r * 10 + A[i];\n        C.push_back(r &#x2F; b);\n        r %&#x3D; b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n\n794. 高精度除法\n\n前缀和\n\n\n\n\n\n\n\n\n一维前缀和\n二维前缀和\n一维前缀和S[i] &#x3D; a[1] + a[2] + ... a[i]\na[l] + ... + a[r] &#x3D; S[r] - S[l - 1]\n\n795. 前缀和\n二维前缀和S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n\n796. 子矩阵的和\n\n差分\n\n\n\n\n\n\n\n\n一维差分\n二维差分\n一维差分给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c\n\n797. 差分\n二维差分给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c\n\n798. 差分矩阵\n\n位运算求n的第k位数字: n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n\n\n801. 二进制中1的个数\n\n双指针算法for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n\n    &#x2F;&#x2F; 具体问题的逻辑\n&#125;\n常见问题分类：\n    (1) 对于一个序列，用两个指针维护一段区间\n    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n\n799. 最长连续不重复子序列\n800. 数组元素的目标和\n\n离散化vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;\n\n802. 区间和\n\n区间合并&#x2F;&#x2F; 将所有存在交集的区间合并\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st &#x3D; -2e9, ed &#x3D; -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n            st &#x3D; seg.first, ed &#x3D; seg.second;\n        &#125;\n        else ed &#x3D; max(ed, seg.second);\n\n    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs &#x3D; res;\n&#125;\n\n803.区间合并\n\n","slug":"基础算法模板","date":"2022-04-10T09:57:57.000Z","categories_index":"","tags_index":"模板,算法,基础算法","author_index":"Soul_15a"}]