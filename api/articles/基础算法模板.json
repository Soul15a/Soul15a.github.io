{"title":"基础算法模板","uid":"cad29d88a5e84162d8735ff1cbc7e6a8","slug":"基础算法模板","date":"2022-04-10T09:57:57.000Z","updated":"2022-04-10T12:09:00.366Z","comments":true,"path":"api/articles/基础算法模板.json","keywords":null,"cover":null,"content":"<p><strong>本篇文章旨在介绍基础算法模板</strong>。</p>\n<p><strong>二分，前缀和，差分，双指针较重要，望重点掌握</strong></p>\n<p><strong>包括：快速排序，归并排序，离散化，前缀和，差分，双指针，区间合并，高精度，位运算</strong></p>\n<p><strong>整理自acwing</strong><br>………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….</p>\n<h1 id=\"快速排序模板\"><a href=\"#快速排序模板\" class=\"headerlink\" title=\"快速排序模板\"></a>快速排序模板</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void quick_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;</code></pre>\n\n<p><strong>学思想</strong></p>\n<p><strong>algorithm库中有一个sort函数相当于快排，不用手写</strong></p>\n<p><a href=\"https://www.acwing.com/problem/content/787/\">785. 快速排序</a></p>\n<hr>\n<h1 id=\"归并排序模板\"><a href=\"#归并排序模板\" class=\"headerlink\" title=\"归并排序模板\"></a>归并排序模板</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int mid &#x3D; l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];\n        else tmp[k ++ ] &#x3D; q[j ++ ];\n\n    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];\n    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];\n\n    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/789/\">787.归并排序</a></p>\n<p><strong>利用归并排序的思想可以解决逆序对的问题</strong></p>\n<p><a href=\"https://www.acwing.com/problem/content/790/\">788. 逆序对的数量</a></p>\n<hr>\n<h1 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>整数二分</p>\n<p>浮点数二分</p></blockquote>\n<h2 id=\"整数二分模板\"><a href=\"#整数二分模板\" class=\"headerlink\" title=\"整数二分模板\"></a>整数二分模板</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质\n        else l &#x3D; mid + 1;\n    &#125;\n    return l;\n&#125;\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l &#x3D; mid;\n        else r &#x3D; mid - 1;\n    &#125;\n    return l;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/791/\">789. 数的范围</a></p>\n<h2 id=\"浮点数二分\"><a href=\"#浮点数二分\" class=\"headerlink\" title=\"浮点数二分\"></a>浮点数二分</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid &#x3D; (l + r) &#x2F; 2;\n        if (check(mid)) r &#x3D; mid;\n        else l &#x3D; mid;\n    &#125;\n    return l;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/792/\">790. 数的三次方根</a></p>\n<hr>\n<h1 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h1><p><del>缺少高精度乘高精度</del></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>高精度加法</p>\n<p>高精度减法</p>\n<p>高精度乘以高精度</p>\n<p>高精度除以高精度</p></blockquote>\n<h2 id=\"高精度加法\"><a href=\"#高精度加法\" class=\"headerlink\" title=\"高精度加法\"></a>高精度加法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t +&#x3D; A[i];\n        if (i &lt; B.size()) t +&#x3D; B[i];\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/793/\">791. 高精度加法</a></p>\n<h2 id=\"高精度减法\"><a href=\"#高精度减法\" class=\"headerlink\" title=\"高精度减法\"></a>高精度减法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t &#x3D; A[i] - t;\n        if (i &lt; B.size()) t -&#x3D; B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t &#x3D; 1;\n        else t &#x3D; 0;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/794/\">792. 高精度减法</a></p>\n<h2 id=\"高精度乘以低精度\"><a href=\"#高精度乘以低精度\" class=\"headerlink\" title=\"高精度乘以低精度\"></a>高精度乘以低精度</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t +&#x3D; A[i] * b;\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n    return C;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/795/\">793. 高精度乘法</a></p>\n<h2 id=\"高精度除以低精度\"><a href=\"#高精度除以低精度\" class=\"headerlink\" title=\"高精度除以低精度\"></a>高精度除以低精度</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r &#x3D; 0;\n    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )\n    &#123;\n        r &#x3D; r * 10 + A[i];\n        C.push_back(r &#x2F; b);\n        r %&#x3D; b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/796/\">794. 高精度除法</a></p>\n<hr>\n<h1 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一维前缀和</p>\n<p>二维前缀和</p></blockquote>\n<h2 id=\"一维前缀和\"><a href=\"#一维前缀和\" class=\"headerlink\" title=\"一维前缀和\"></a>一维前缀和</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">S[i] &#x3D; a[1] + a[2] + ... a[i]\na[l] + ... + a[r] &#x3D; S[r] - S[l - 1]</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/797/\">795. 前缀和</a></p>\n<h2 id=\"二维前缀和\"><a href=\"#二维前缀和\" class=\"headerlink\" title=\"二维前缀和\"></a>二维前缀和</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/798/\">796. 子矩阵的和</a></p>\n<hr>\n<h1 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一维差分</p>\n<p>二维差分</p></blockquote>\n<h2 id=\"一维差分\"><a href=\"#一维差分\" class=\"headerlink\" title=\"一维差分\"></a>一维差分</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/799/\">797. 差分</a></p>\n<h1 id=\"二维差分\"><a href=\"#二维差分\" class=\"headerlink\" title=\"二维差分\"></a>二维差分</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/800/\">798. 差分矩阵</a></p>\n<hr>\n<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">求n的第k位数字: n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/803/\">801. 二进制中1的个数</a></p>\n<hr>\n<h1 id=\"双指针算法\"><a href=\"#双指针算法\" class=\"headerlink\" title=\"双指针算法\"></a>双指针算法</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n\n    &#x2F;&#x2F; 具体问题的逻辑\n&#125;\n常见问题分类：\n    (1) 对于一个序列，用两个指针维护一段区间\n    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/801/\">799. 最长连续不重复子序列</a></p>\n<p><a href=\"https://www.acwing.com/problem/content/802/\">800. 数组元素的目标和</a></p>\n<hr>\n<h1 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/804/\">802. 区间和</a></p>\n<hr>\n<h1 id=\"区间合并\"><a href=\"#区间合并\" class=\"headerlink\" title=\"区间合并\"></a>区间合并</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 将所有存在交集的区间合并\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st &#x3D; -2e9, ed &#x3D; -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n            st &#x3D; seg.first, ed &#x3D; seg.second;\n        &#125;\n        else ed &#x3D; max(ed, seg.second);\n\n    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs &#x3D; res;\n&#125;</code></pre>\n\n<p><a href=\"https://www.acwing.com/problem/content/805/\">803.区间合并</a></p>\n<hr>\n","text":"本篇文章旨在介绍基础算法模板。 二分，前缀和，差分，双指针较重要，望重点掌握 包括：快速排序，归并排序，离散化，前缀和，差分，双指针，区间合并，高精度，位运算 整理自acwing………………………………………………………………………………………………………………………………………...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"},{"name":"基础算法","slug":"基础算法","count":1,"path":"api/tags/基础算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">快速排序模板</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">归并排序模板</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">二分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">整数二分模板</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">浮点数二分</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6\"><span class=\"toc-text\">高精度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">高精度加法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95\"><span class=\"toc-text\">高精度减法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6\"><span class=\"toc-text\">高精度乘以低精度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6\"><span class=\"toc-text\">高精度除以低精度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80%E5%92%8C\"><span class=\"toc-text\">前缀和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\"><span class=\"toc-text\">一维前缀和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\"><span class=\"toc-text\">二维前缀和</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B7%AE%E5%88%86\"><span class=\"toc-text\">差分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86\"><span class=\"toc-text\">一维差分</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86\"><span class=\"toc-text\">二维差分</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">位运算</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">双指针算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A6%BB%E6%95%A3%E5%8C%96\"><span class=\"toc-text\">离散化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">区间合并</span></a></li></ol>","author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构模板","uid":"1df484034a65ae4d42f3134f61bf20af","slug":"数据结构模板","date":"2022-04-10T11:55:19.000Z","updated":"2022-04-10T12:16:00.974Z","comments":true,"path":"api/articles/数据结构模板.json","keywords":null,"cover":null,"text":"本篇文章旨在介绍基础数据结构模板。 算法竞赛中，利用指针的数据结构跑的太慢，故使用数组来表示的数据结构 包括：单链表 双链表 栈 队列 单调栈 单调队列 KMP Trie树 并查集 堆 一般哈希 字符串哈希 整理自acwing………………………………………………………………………...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}