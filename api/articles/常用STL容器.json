{"title":"常用STL容器","uid":"80578d34de98ea10cb7435fc76a1d430","slug":"常用STL容器","date":"2022-04-10T12:09:45.000Z","updated":"2022-04-10T13:26:55.778Z","comments":true,"path":"api/articles/常用STL容器.json","keywords":null,"cover":null,"content":"<p><strong>本篇文章旨在介绍常用STL容器</strong>。</p>\n<p><strong>整理自acwing</strong></p>\n<p>………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….<br>………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….</p>\n<h2 id=\"vector-变长数组，倍增的思想\"><a href=\"#vector-变长数组，倍增的思想\" class=\"headerlink\" title=\"vector, 变长数组，倍增的思想\"></a>vector, 变长数组，倍增的思想</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()  返回元素个数\nempty()  返回是否为空\nclear()  清空\nfront()&#x2F;back()\npush_back()&#x2F;pop_back()\nbegin()&#x2F;end()\n[]\n支持比较运算，按字典序</code></pre>\n\n<hr>\n<h2 id=\"pair-lt-int-int-gt\"><a href=\"#pair-lt-int-int-gt\" class=\"headerlink\" title=\"pair&lt;int, int&gt;\"></a>pair&lt;int, int&gt;</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">first, 第一个元素\nsecond, 第二个元素\n支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</code></pre>\n\n<hr>\n<h2 id=\"string，字符串\"><a href=\"#string，字符串\" class=\"headerlink\" title=\"string，字符串\"></a>string，字符串</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()&#x2F;length()  返回字符串长度\nempty()\nclear()\nsubstr(起始下标，(子串长度))  返回子串\nc_str()  返回字符串所在字符数组的起始地址</code></pre>\n\n<hr>\n<h2 id=\"queue-队列\"><a href=\"#queue-队列\" class=\"headerlink\" title=\"queue, 队列\"></a>queue, 队列</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()\nempty()\npush()  向队尾插入一个元素\nfront()  返回队头元素\nback()  返回队尾元素\npop()  弹出队头元素</code></pre>\n\n<hr>\n<h2 id=\"priority-queue-优先队列，默认是大根堆\"><a href=\"#priority-queue-优先队列，默认是大根堆\" class=\"headerlink\" title=\"priority_queue, 优先队列，默认是大根堆\"></a>priority_queue, 优先队列，默认是大根堆</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()\nempty()\npush()  插入一个元素\ntop()  返回堆顶元素\npop()  弹出堆顶元素\n定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code></pre>\n\n<hr>\n<h2 id=\"stack-栈\"><a href=\"#stack-栈\" class=\"headerlink\" title=\"stack, 栈\"></a>stack, 栈</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()\nempty()\npush()  向栈顶插入一个元素\ntop()  返回栈顶元素\npop()  弹出栈顶元素</code></pre>\n\n<hr>\n<h2 id=\"deque-双端队列\"><a href=\"#deque-双端队列\" class=\"headerlink\" title=\"deque, 双端队列\"></a>deque, 双端队列</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()\nempty()\nclear()\nfront()&#x2F;back()\npush_back()&#x2F;pop_back()\npush_front()&#x2F;pop_front()\nbegin()&#x2F;end()\n[]</code></pre>\n\n<hr>\n<h2 id=\"set-map-multiset-multimap-基于平衡二叉树（红黑树），动态维护有序序列\"><a href=\"#set-map-multiset-multimap-基于平衡二叉树（红黑树），动态维护有序序列\" class=\"headerlink\" title=\"set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\"></a>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">size()\nempty()\nclear()\nbegin()&#x2F;end()\n++, -- 返回前驱和后继，时间复杂度 O(logn)\n\nset&#x2F;multiset\n    insert()  插入一个数\n    find()  查找一个数\n    count()  返回某一个数的个数\n    erase()\n        (1) 输入是一个数x，删除所有x   O(k + logn)\n        (2) 输入一个迭代器，删除这个迭代器\n    lower_bound()&#x2F;upper_bound()\n        lower_bound(x)  返回大于等于x的最小的数的迭代器\n        upper_bound(x)  返回大于x的最小的数的迭代器\nmap&#x2F;multimap\n    insert()  插入的数是一个pair\n    erase()  输入的参数是pair或者迭代器\n    find()\n    []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n    lower_bound()&#x2F;upper_bound()</code></pre>\n\n<hr>\n<h2 id=\"unordered-set-unordered-map-unordered-multiset\"><a href=\"#unordered-set-unordered-map-unordered-multiset\" class=\"headerlink\" title=\"unordered_set, unordered_map, unordered_multiset,\"></a>unordered_set, unordered_map, unordered_multiset,</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--</code></pre>\n\n<hr>\n<h2 id=\"bitset-圧位\"><a href=\"#bitset-圧位\" class=\"headerlink\" title=\"bitset, 圧位\"></a>bitset, 圧位</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bitset&lt;10000&gt; s;\n~, &amp;, |, ^\n&gt;&gt;, &lt;&lt;\n&#x3D;&#x3D;, !&#x3D;\n[]\n\ncount()  返回有多少个1\n\nany()  判断是否至少有一个1\nnone()  判断是否全为0\n\nset()  把所有位置成1\nset(k, v)  将第k位变成v\nreset()  把所有位变成0\nflip()  等价于~\nflip(k) 把第k位取反</code></pre>","text":"本篇文章旨在介绍常用STL容器。 整理自acwing ………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….………………………...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"},{"name":"STL","slug":"STL","count":1,"path":"api/tags/STL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vector-%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%EF%BC%8C%E5%80%8D%E5%A2%9E%E7%9A%84%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">vector, 变长数组，倍增的思想</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pair-lt-int-int-gt\"><span class=\"toc-text\">pair&lt;int, int&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#string%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">string，字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#queue-%E9%98%9F%E5%88%97\"><span class=\"toc-text\">queue, 队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#priority-queue-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E5%A4%A7%E6%A0%B9%E5%A0%86\"><span class=\"toc-text\">priority_queue, 优先队列，默认是大根堆</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#stack-%E6%A0%88\"><span class=\"toc-text\">stack, 栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deque-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">deque, 双端队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#set-map-multiset-multimap-%E5%9F%BA%E4%BA%8E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89%EF%BC%8C%E5%8A%A8%E6%80%81%E7%BB%B4%E6%8A%A4%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#unordered-set-unordered-map-unordered-multiset\"><span class=\"toc-text\">unordered_set, unordered_map, unordered_multiset,</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bitset-%E5%9C%A7%E4%BD%8D\"><span class=\"toc-text\">bitset, 圧位</span></a></li></ol>","author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"mysql基础","uid":"ff3dfd0caecb8a3b5b7353d12c1be784","slug":"mysql基础","date":"2022-04-14T03:26:44.000Z","updated":"2022-04-14T03:53:40.086Z","comments":true,"path":"api/articles/mysql基础.json","keywords":null,"cover":[],"text":"引用—-黑马程序员javawebMySQL基础SQL 英文：Structured Query Language，简称 SQL，结构化查询语言 操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"-mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构模板","uid":"1df484034a65ae4d42f3134f61bf20af","slug":"数据结构模板","date":"2022-04-10T11:55:19.000Z","updated":"2022-04-10T12:16:00.974Z","comments":true,"path":"api/articles/数据结构模板.json","keywords":null,"cover":null,"text":"本篇文章旨在介绍基础数据结构模板。 算法竞赛中，利用指针的数据结构跑的太慢，故使用数组来表示的数据结构 包括：单链表 双链表 栈 队列 单调栈 单调队列 KMP Trie树 并查集 堆 一般哈希 字符串哈希 整理自acwing………………………………………………………………………...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}