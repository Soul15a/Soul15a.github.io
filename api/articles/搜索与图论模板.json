{"title":"搜索与图论模板","uid":"d11324b19b05ce1c671aea0ac57ea0cf","slug":"搜索与图论模板","date":"2022-04-10T12:18:56.000Z","updated":"2022-04-10T13:28:16.382Z","comments":true,"path":"api/articles/搜索与图论模板.json","keywords":null,"cover":null,"content":"<p><strong>本篇文章旨在介绍搜索与图论模板</strong>。</p>\n<p><strong>在算法竞赛中，普通的指针建图方式过于慢了，所以采用数组的存储方式，最短路算法以及最小生成树算法很重要，spfa算法一般不用，因为spfa容易被卡，dijkstra算法用的比较多</strong></p>\n<p><strong>包括：树与图的存储，拓扑排序，朴素dijkstra，堆优化版dijkstra，Bellman-Ford算法，spfa 算法（队列优化的Bellman-Ford算法），spfa判断图中是否存在负环，floyd算法，朴素版prim算法，Kruskal算法，染色法判别二分图，匈牙利算法</strong></p>\n<p><strong>整理自acwing</strong></p>\n<h1 id=\"树与图的存储\"><a href=\"#树与图的存储\" class=\"headerlink\" title=\"树与图的存储\"></a>树与图的存储</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n&#x2F;&#x2F; 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 初始化\nidx &#x3D; 0;\nmemset(h, -1, sizeof h);</code></pre>\n\n<hr>\n<h1 id=\"树与图的遍历\"><a href=\"#树与图的遍历\" class=\"headerlink\" title=\"树与图的遍历\"></a>树与图的遍历</h1><h2 id=\"深度优先搜索-dfs\"><a href=\"#深度优先搜索-dfs\" class=\"headerlink\" title=\"深度优先搜索(dfs)\"></a>深度优先搜索(dfs)</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int dfs(int u)\n&#123;\n    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过\n\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/848/\">846. 树的重心</a></p>\n<hr>\n<h2 id=\"广度优先搜索-bfs\"><a href=\"#广度优先搜索-bfs\" class=\"headerlink\" title=\"广度优先搜索(bfs)\"></a>广度优先搜索(bfs)</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">queue&lt;int&gt; q;\nst[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n&#123;\n    int t &#x3D; q.front();\n    q.pop();\n\n    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过\n            q.push(j);\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/849/\">847. 图中点的层次 </a></p>\n<hr>\n<h1 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool topsort()\n&#123;\n    int hh &#x3D; 0, tt &#x3D; -1;\n\n    &#x2F;&#x2F; d[i] 存储点i的入度\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (!d[i])\n            q[ ++ tt] &#x3D; i;\n\n    while (hh &lt;&#x3D; tt)\n    &#123;\n        int t &#x3D; q[hh ++ ];\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (-- d[j] &#x3D;&#x3D; 0)\n                q[ ++ tt] &#x3D; j;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt &#x3D;&#x3D; n - 1;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/850/\">848. 有向图的拓扑序列 </a></p>\n<hr>\n<h1 id=\"最短路算法\"><a href=\"#最短路算法\" class=\"headerlink\" title=\"最短路算法\"></a>最短路算法</h1><h2 id=\"朴素dijkstra\"><a href=\"#朴素dijkstra\" class=\"headerlink\" title=\"朴素dijkstra\"></a>朴素dijkstra</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int g[N][N];  &#x2F;&#x2F; 存储每条边\nint dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离\nbool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; n - 1; i ++ )\n    &#123;\n        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        &#x2F;&#x2F; 用t更新其他点的距离\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);\n\n        st[t] &#x3D; true;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/851/\">849. Dijkstra求最短路 I </a></p>\n<hr>\n<h2 id=\"堆优化版dijkstra\"><a href=\"#堆优化版dijkstra\" class=\"headerlink\" title=\"堆优化版dijkstra\"></a>堆优化版dijkstra</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef pair&lt;int, int&gt; PII;\n\nint n;      &#x2F;&#x2F; 点的数量\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号\n\n    while (heap.size())\n    &#123;\n        auto t &#x3D; heap.top();\n        heap.pop();\n\n        int ver &#x3D; t.second, distance &#x3D; t.first;\n\n        if (st[ver]) continue;\n        st[ver] &#x3D; true;\n\n        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] &#x3D; distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/852/\">850. Dijkstra求最短路 II </a></p>\n<hr>\n<h2 id=\"Bellman-Ford算法\"><a href=\"#Bellman-Ford算法\" class=\"headerlink\" title=\"Bellman-Ford算法\"></a>Bellman-Ford算法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\n\nint n, m;       &#x2F;&#x2F; n表示点数，m表示边数\nint dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离\n\nstruct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        for (int j &#x3D; 0; j &lt; m; j ++ )\n        &#123;\n            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] &#x3D; dist[a] + w;\n        &#125;\n    &#125;\n\n    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;\n    return dist[n];\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/855/\">853. 有边数限制的最短路 </a></p>\n<hr>\n<h2 id=\"spfa-算法（队列优化的Bellman-Ford算法）\"><a href=\"#spfa-算法（队列优化的Bellman-Ford算法）\" class=\"headerlink\" title=\"spfa 算法（队列优化的Bellman-Ford算法）\"></a>spfa 算法（队列优化的Bellman-Ford算法）</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] &#x3D; true;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/853/\">851. spfa求最短路 </a></p>\n<hr>\n<h2 id=\"spfa判断图中是否存在负环\"><a href=\"#spfa判断图中是否存在负环\" class=\"headerlink\" title=\"spfa判断图中是否存在负环\"></a>spfa判断图中是否存在负环</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    &#x2F;&#x2F; 不需要初始化dist数组\n    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int&gt; q;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        q.push(i);\n        st[i] &#x3D; true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                cnt[j] &#x3D; cnt[t] + 1;\n                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/854/\">852. spfa判断负环</a></p>\n<hr>\n<h2 id=\"floyd算法-多源最短路\"><a href=\"#floyd算法-多源最短路\" class=\"headerlink\" title=\"floyd算法(多源最短路)\"></a>floyd算法(多源最短路)</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">初始化：\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;\n            else d[i][j] &#x3D; INF;\n\n&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/856/\">854. Floyd求最短路 </a></p>\n<hr>\n<h1 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h1><h2 id=\"朴素版prim算法\"><a href=\"#朴素版prim算法\" class=\"headerlink\" title=\"朴素版prim算法\"></a>朴素版prim算法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n;      &#x2F;&#x2F; n表示点数\nint g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边\nint dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中\n\n\n&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    int res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        int t &#x3D; -1;\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;\n\n        if (i) res +&#x3D; dist[t];\n        st[t] &#x3D; true;\n\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);\n    &#125;\n\n    return res;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/860/\">858. Prim算法求最小生成树 </a></p>\n<hr>\n<h2 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n, m;       &#x2F;&#x2F; n是点数，m是边数\nint p[N];       &#x2F;&#x2F; 并查集的父节点数组\n\nstruct Edge     &#x2F;&#x2F; 存储边\n&#123;\n    int a, b, w;\n\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\n\nint find(int x)     &#x2F;&#x2F; 并查集核心操作\n&#123;\n    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集\n\n    int res &#x3D; 0, cnt &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; m; i ++ )\n    &#123;\n        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;\n\n        a &#x3D; find(a), b &#x3D; find(b);\n        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并\n        &#123;\n            p[a] &#x3D; b;\n            res +&#x3D; w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/861/\">859. Kruskal算法求最小生成树</a></p>\n<hr>\n<h2 id=\"染色法判别二分图\"><a href=\"#染色法判别二分图\" class=\"headerlink\" title=\"染色法判别二分图\"></a>染色法判别二分图</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n;      &#x2F;&#x2F; n表示点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图\nint color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] &#x3D; c;\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (color[j] &#x3D;&#x3D; -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] &#x3D;&#x3D; c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag &#x3D; true;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (color[i] &#x3D;&#x3D; -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag &#x3D; false;\n                break;\n            &#125;\n    return flag;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/863/\">861. 二分图的最大匹配 </a></p>\n<hr>\n<h2 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n&#123;\n    for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true;\n            if (match[j] &#x3D;&#x3D; 0 || find(match[j]))\n            &#123;\n                match[j] &#x3D; x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n&#125;</code></pre>\n<p><a href=\"https://www.acwing.com/problem/content/862/\">860. 染色法判定二分图 </a></p>\n","feature":true,"text":"本篇文章旨在介绍搜索与图论模板。 在算法竞赛中，普通的指针建图方式过于慢了，所以采用数组的存储方式，最短路算法以及最小生成树算法很重要，spfa算法一般不用，因为spfa容易被卡，dijkstra算法用的比较多 包括：树与图的存储，拓扑排序，朴素dijkstra，堆优化版dijk...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"},{"name":"搜索","slug":"搜索","count":1,"path":"api/tags/搜索.json"},{"name":"图论","slug":"图论","count":1,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":1,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":1,"path":"api/tags/bfs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">树与图的存储</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">树与图的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs\"><span class=\"toc-text\">深度优先搜索(dfs)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs\"><span class=\"toc-text\">广度优先搜索(bfs)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">拓扑排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">最短路算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0dijkstra\"><span class=\"toc-text\">朴素dijkstra</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88dijkstra\"><span class=\"toc-text\">堆优化版dijkstra</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Bellman-Ford%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Bellman-Ford算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#spfa-%E7%AE%97%E6%B3%95%EF%BC%88%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E7%9A%84Bellman-Ford%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">spfa 算法（队列优化的Bellman-Ford算法）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#spfa%E5%88%A4%E6%96%AD%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B4%9F%E7%8E%AF\"><span class=\"toc-text\">spfa判断图中是否存在负环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#floyd%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF\"><span class=\"toc-text\">floyd算法(多源最短路)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">最小生成树算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E7%89%88prim%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">朴素版prim算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kruskal%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Kruskal算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%88%AB%E4%BA%8C%E5%88%86%E5%9B%BE\"><span class=\"toc-text\">染色法判别二分图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">匈牙利算法</span></a></li></ol></li></ol>","author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"mysql基础","uid":"ff3dfd0caecb8a3b5b7353d12c1be784","slug":"mysql基础","date":"2022-04-14T03:26:44.000Z","updated":"2022-04-14T03:53:40.086Z","comments":true,"path":"api/articles/mysql基础.json","keywords":null,"cover":[],"text":"引用—-黑马程序员javawebMySQL基础SQL 英文：Structured Query Language，简称 SQL，结构化查询语言 操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"-mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"常用STL容器","uid":"80578d34de98ea10cb7435fc76a1d430","slug":"常用STL容器","date":"2022-04-10T12:09:45.000Z","updated":"2022-04-10T13:26:55.778Z","comments":true,"path":"api/articles/常用STL容器.json","keywords":null,"cover":null,"text":"本篇文章旨在介绍常用STL容器。 整理自acwing ………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….………………………...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"},{"name":"STL","slug":"STL","count":1,"path":"api/tags/STL.json"}],"author":{"name":"Soul_15a","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Soul15a","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}